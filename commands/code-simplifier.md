# Code Simplifier

機能が動いた後のクリーンアップ。動作を変えずにコードをシンプルにする。
「シンプル」とは短いことではなく、意図が明確で読みやすいこと。

## タスク

$ARGUMENTS

## 実行プロセス

### Step 1: 対象ファイルの特定

`git diff` で直近の変更を確認し、変更されたファイルを特定する:

```bash
# ステージング済みの変更
git diff --cached --name-only

# 未ステージの変更
git diff --name-only

# 直近コミットの変更
git diff HEAD~1 --name-only
```

$ARGUMENTS で特定のファイルやディレクトリが指定されている場合は、そちらを優先する。

### Step 2: 変更ファイルの分析

各ファイルについて以下を確認:

- ファイルの責務（何をするファイルか）
- 変更の内容（何が追加・変更されたか）
- テストの有無（対応するテストファイルがあるか）

### Step 3: シンプル化の実行

以下の観点で、1つずつ改善する。各改善後にテストを実行して壊れていないか確認する。

#### 3a. 不要な抽象化の除去

- 1箇所からしか呼ばれない関数 → インライン化を検討
- 1つの実装しかないインターフェース → 直接参照を検討
- 過剰なラッパークラス → 除去を検討
- ただし、将来の拡張が明確に予定されている場合はスキップ

#### 3b. 変数名・関数名の改善

- 略語を避ける（`usr` → `user`, `btn` → `button`）
- 何をするかが名前で分かる（`processData` → `validateUserInput`）
- ブール値は疑問形（`isValid`, `hasPermission`, `canEdit`）
- 一文字変数はループカウンターのみ許容

#### 3c. 重複コードの統合

- 同じロジックが2箇所以上 → 共通関数に抽出
- 似ているが微妙に違うロジック → パラメータ化で統合できるか検討
- ただし、無理な共通化で可読性が下がるなら重複を許容する

#### 3d. 複雑な条件分岐の整理

- ネスト3段以上 → early return で平坦化
- 複雑な条件式 → 意味のある変数に分離（`const isEligible = age >= 18 && hasConsent`）
- switch/if-else チェーン → オブジェクトマッピングやポリモーフィズムを検討

#### 3e. 不要なコメントの除去

- コードを読めば分かるコメント → 削除
- 古い・不正確なコメント → 削除
- TODO/FIXME → 対応できるなら対応する。できないなら残す
- 「なぜ」を説明するコメント → 残す（WHY コメントは価値がある）

### Step 4: 最終確認

全ての変更が完了したら:

1. テストスイートを実行して全パスを確認
2. Lint を実行
3. 変更サマリーを出力:
   - 改善したファイル一覧
   - 各ファイルでの主な改善内容
   - スキップした箇所とその理由

## ルール

- 動作を変えない。リファクタリングのみ
- 各変更後にテスト実行。壊れたら即座にロールバック
- 判断に迷ったら変更しない（保守的に進める）
- 一度に大きく変えない。小さな改善の積み重ね
- 既存のコーディングスタイルに合わせる（自分の好みを押し付けない）
